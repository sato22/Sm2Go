package sm2go

import (
	"fmt"
)

/*
【実装したもの】
・基本的なステートマシン図の変換を実装　〇
	→　 ・ステートマシン図の挙動をGo言語でどのように記述するか（sample.go, sample_edit.go）　〇
		・sampleを基に，ソースコードを出力する処理を記述　〇
・diagrams.netを用いて生成したXMLファイルから情報を取り出す　〇
・ステートマシン図から生成されたxmlファイルを基にソースコードを生成　〇
・二重構造のxmlファイルから情報を取り出す　〇
・コマンドラインツールとしての機能を実装 〇
・直接ファイルに出力する 〇

【すること】
・合成状態の変換を実装
	→　 ・ステートマシン図の挙動をGo言語でどのように記述するか（sample.go, sample_edit.go）
		・sampleを基に，ソースコードを出力する処理を記述
*/

var oline []string
var oeline []string

func remove(transition_list []*Transition, state_name *State) []*Transition {
	ret := make([]*Transition, len(transition_list))
	i := 0

	for _, transition := range transition_list {
		if state_name != transition.Src {
			ret[i] = transition
			i++
		}
	}

	return ret[:i]
}

// ------------------------------　output.go　-----------------------------------

func writePackage() {
	oline = append(oline, "// Please do not edit this file.\n")
	oline = append(oline, "// go run *.go\n")
	oline = append(oline, "\n")

	oline = append(oline, "package main\n")
	oline = append(oline, "\n")

	oline = append(oline, "import (\n")
	oline = append(oline, "\"fmt\"\n")
	oline = append(oline, ")\n")
	oline = append(oline, "\n")
}

func writeEnum(state_list []*State) {
	// enum宣言
	oline = append(oline, "type State int\n")
	oline = append(oline, "const (\n")
	for index, state := range state_list {
		if index == 0 {
			oline = append(oline, state.Name, "State = iota\n")
			continue
		}
		oline = append(oline, state.Name)
	}
	oline = append(oline, ")\n")
	oline = append(oline, "\n")

	oline = append(oline, "type Eod int\n")
	oline = append(oline, "const (\n")
	oline = append(oline, "Entry Eod = iota\nDo\nExit\n)\n")
	oline = append(oline, "\n")

	oline = append(oline, "var input string\n")
	oline = append(oline, "var eod Eod\n")
	oline = append(oline, "var current_state State\n")
	oline = append(oline, "\n")
}

func writeEvent(transition_list []*Transition) {
	// 状態ごとの関数を作成
	oline = append(oline, "func task1() {\n")
	oline = append(oline, "switch current_state {\n")

	for _, transition := range transition_list {
		oline = append(oline, fmt.Sprintf("case %s:\n", transition.Src.Name))
		state_name := transition.Src
		// Entry状態での動作を記述
		oline = append(oline, "if eod == Entry {\n")
		oline = append(oline, fmt.Sprintf("%s_Entry()\n", transition.Src.Name))
		oline = append(oline, "eod = Do\n")
		oline = append(oline, "}\n") // if eod == Entry

		// Do状態での動作を記述
		oline = append(oline, "if eod == Do {\n")
		oline = append(oline, fmt.Sprintf("%s_Do()\n", transition.Src.Name))
		// 遷移条件を列挙
		for _, transition := range transition_list {
			if state_name == transition.Src {
				oline = append(oline, fmt.Sprintf("if %s_Cond() {\n", transition.Event.Name))
				oline = append(oline, fmt.Sprintf("current_state = %s\n", transition.Dest.Name))
				oline = append(oline, fmt.Sprintf("fmt.Println(\"State is changed: %s to %s\")\n", transition.Src.Name, transition.Dest.Name))
				oline = append(oline, "eod = Entry\n")
				oline = append(oline, "}\n") // if event_Cond()
			}
		}

		transition_list = remove(transition_list, state_name) // 表示したtransitionをリストから削除
		if len(transition_list) == 0 {
			break
		}
		oline = append(oline, "}\n") // if eod == Do
	}
	oline = append(oline, "}\n") // switch state
	oline = append(oline, "}\n") // func
	oline = append(oline, "}\n") // func
	oline = append(oline, "\n")
}

func writeInit(initial *State) {
	oline = append(oline, "func init() {\n")
	oline = append(oline, fmt.Sprintf("current_state = %s\n", initial.Name))
	oline = append(oline, "eod = Entry\n")
	oline = append(oline, "}\n")
	oline = append(oline, "\n")
}

// ------------------------------　output_edit.go　-----------------------------------

func writePackageEdit() {
	oeline = append(oeline, "// Please edit this file\n")
	oeline = append(oeline, "// go run *.go\n")
	oeline = append(oeline, "\n")

	oeline = append(oeline, "package main\n")
	oeline = append(oeline, "\n")

	oeline = append(oeline, "import (\n")
	oeline = append(oeline, "\"fmt\"\n")
	oeline = append(oeline, "\"time\"\n")
	oeline = append(oeline, ")\n")
	oeline = append(oeline, "\n")
}

func writeFunc(state_list []*State, event_list []*Event) {
	for _, state := range state_list {
		oeline = append(oeline, fmt.Sprintf("func %s_Entry() {\n", state.Name))
		oeline = append(oeline, "// nothing to do\n")
		oeline = append(oeline, "}\n")
		oeline = append(oeline, "\n")

		oeline = append(oeline, fmt.Sprintf("func %s_Do() {\n", state.Name))
		oeline = append(oeline, "// nothing to do\n")
		oeline = append(oeline, "}\n")
		oeline = append(oeline, "\n")

		oeline = append(oeline, fmt.Sprintf("func %s_Exit() {\n", state.Name))
		oeline = append(oeline, "// nothing to do\n")
		oeline = append(oeline, "}\n")
		oeline = append(oeline, "\n")
	}

	for _, event := range event_list {
		oeline = append(oeline, fmt.Sprintf("func %s_Cond() bool {\n", event.Name))
		oeline = append(oeline, "// Please write the conditions under which a state transitions\n")
		oeline = append(oeline, "return true\n")
		oeline = append(oeline, "}\n")
		oeline = append(oeline, "\n")
	}

}

func writeMain() {
	oeline = append(oeline, "func main() {\n")
	oeline = append(oeline, "go func() {\n")
	oeline = append(oeline, "for {\n")
	oeline = append(oeline, "time.Sleep(1 * time.Millisecond)\n")
	oeline = append(oeline, "task1()\n")
	oeline = append(oeline, "}\n")
	oeline = append(oeline, "}()\n")
	oeline = append(oeline, "for {\n")
	oeline = append(oeline, "fmt.Scan(&input)\n")
	oeline = append(oeline, "if input == \"q\" {\n")
	oeline = append(oeline, "fmt.Println(\"quit\")\n")
	oeline = append(oeline, "break\n")
	oeline = append(oeline, "}\n")
	oeline = append(oeline, "}\n")
	oeline = append(oeline, "}\n")
	oeline = append(oeline, "\n")
}
