package sm2go

import (
	"fmt"
	"strings"
)

const (
	debugLog  = false
	debugTest = false
)

// ------------------------------　hogehoge_base.go　-----------------------------------

func writePackage(oline []string, name string, count int) []string {
	oline = append(oline, fmt.Sprintf("package %s\n", name))

	if count == 0 {
		oline = append(oline, `
		// Please do not edit this file.

		import (
		// package name to import
		)

		const (
			debug = true
		)
		`)
	} else {
		oline = append(oline, `
			// Please do not edit this file.

			import (
			// package name to import
			)
			`)
	}

	return oline
}

// enum宣言
func writeEnum(oline []string, state_list []*State, m map[string]string, key string, count int) []string {
	oline = append(oline, fmt.Sprintf("type %sState int\n", strings.Title(m[key])))
	oline = append(oline, "const (\n")
	for index, state := range state_list {
		if index == 0 {
			oline = append(oline, fmt.Sprintf("%s %sState = iota\n", state.Name, strings.Title(m[key])))
			continue
		}
		oline = append(oline, fmt.Sprintf("%s\n", state.Name))
	}
	oline = append(oline, ")\n")
	oline = append(oline, "\n")

	if count == 0 {
		oline = append(oline, `
		type Eod int

		const (
			Entry Eod = iota
			Do
			Exit
		)
	`)
	}

	oline = append(oline, fmt.Sprintf("var %seod Eod\n", m[key]))
	oline = append(oline, fmt.Sprintf("var %sCurrentState %sState\n", m[key], strings.Title(m[key])))
	oline = append(oline, "\n")

	return oline
}

// writeStep()関数にて使用
func writeEvent(oline []string, transition_list []*Transition, m map[string]string, key string, state_name *State) []string {
	// 遷移条件を列挙
	for _, transition := range transition_list {
		if state_name == transition.Src {
			oline = append(oline, fmt.Sprintf("if %sCond() {\n", transition.Event.Name))
			oline = append(oline, fmt.Sprintf("%sCurrentState = %s\n", m[key], transition.Dest.Name))
			oline = append(oline, fmt.Sprintf("if debug {\n"))
			oline = append(oline, fmt.Sprintf("logger.Println(\"State is changed: %s to %s\")\n", transition.Src.Name, transition.Dest.Name))
			oline = append(oline, fmt.Sprintf("}\n"))
			oline = append(oline, fmt.Sprintf("%seod = Exit\n", m[key]))
			oline = append(oline, "}\n") // if event_Cond()
		}
	}

	return oline
}

// writeStep()関数にて使用
func writeCase(oline []string, transition_list []*Transition, transition *Transition, m map[string]string, key string, state_name *State) []string {
	oline = append(oline, fmt.Sprintf("case %s:\n", transition.Src.Name))
	// Entry状態での動作を記述
	oline = append(oline, fmt.Sprintf("if %seod == Entry {\n", m[key]))
	oline = append(oline, fmt.Sprintf("%sEntry()\n", strings.ToLower(transition.Src.Name)))
	oline = append(oline, fmt.Sprintf("%seod = Do\n", m[key]))
	oline = append(oline, "}\n") // if eod == Entry

	// Do状態での動作を記述
	oline = append(oline, fmt.Sprintf("if %seod == Do {\n", m[key]))
	oline = append(oline, fmt.Sprintf("%sDo()\n", strings.ToLower(transition.Src.Name)))
	// 遷移条件の記述
	oline = writeEvent(oline, transition_list, m, key, state_name)

	oline = append(oline, "}\n") // if eod == Do

	// Exit状態での動作を記述
	oline = append(oline, fmt.Sprintf("if %seod == Exit {\n", m[key]))
	oline = append(oline, fmt.Sprintf("%sExit()\n", strings.ToLower(transition.Src.Name)))
	oline = append(oline, fmt.Sprintf("%seod = Entry\n", m[key]))
	oline = append(oline, "}\n") // if eod == Exit

	return oline
}

// task関数の生成
func writeStep(oline []string, transition_list []*Transition, m map[string]string, key string) []string {
	// 状態ごとの関数を作成
	oline = append(oline, fmt.Sprintf("func %sStep() {\n", strings.Title(m[key])))
	oline = append(oline, fmt.Sprintf("switch %sCurrentState {\n", m[key]))

	var state_name *State

	for _, transition := range transition_list {
		if state_name != transition.Src {
			state_name = transition.Src
			oline = writeCase(oline, transition_list, transition, m, key, state_name)
		}
	}
	oline = append(oline, "}\n") // switch state
	oline = append(oline, "}\n") // func
	oline = append(oline, "\n")

	return oline
}

// ステートの初期化
func writeInit(oline []string, initial *State, m map[string]string, key string) []string {
	oline = append(oline, "func init() {\n")
	oline = append(oline, fmt.Sprintf("%sCurrentState = %s\n", m[key], initial.Name))
	oline = append(oline, fmt.Sprintf("%seod = Entry\n", m[key]))
	oline = append(oline, "}\n")
	oline = append(oline, "\n")

	return oline
}

// ------------------------------　hogehoge_impl.go　-----------------------------------

// パッケージ名，インポート
func writePackageEdit(oeline []string, name string, count int) []string {
	oeline = append(oeline, fmt.Sprintf("package %s\n", name))

	if count == 0 {
		oeline = append(oeline, `

	// Please edit this file

	import (
		// package name to import
	)

	type DebugLogger interface {
		Println(string)
	}

	var logger DebugLogger

	func ConfigureLog(p DebugLogger) {
		logger = p
	}
	`)
	} else {
		oeline = append(oeline, `

	// Please edit this file

	import (
		// package name to import
	)
	`)
	}

	return oeline

}

// modelBase.goにて使用する関数を表記
func writeFunc(oeline []string, state_list []*State, event_list []*Event) []string {
	for _, state := range state_list {
		oeline = append(oeline, fmt.Sprintf("func %sEntry() {\n", strings.ToLower(state.Name)))
		oeline = append(oeline, "// nothing to do\n")
		oeline = append(oeline, "}\n")
		oeline = append(oeline, "\n")

		oeline = append(oeline, fmt.Sprintf("func %sDo() {\n", strings.ToLower(state.Name)))
		oeline = append(oeline, "// nothing to do\n")
		oeline = append(oeline, "}\n")
		oeline = append(oeline, "\n")

		oeline = append(oeline, fmt.Sprintf("func %sExit() {\n", strings.ToLower(state.Name)))
		oeline = append(oeline, "// nothing to do\n")
		oeline = append(oeline, "}\n")
		oeline = append(oeline, "\n")
	}

	for _, event := range event_list {
		oeline = append(oeline, fmt.Sprintf("func %sCond() bool {\n", event.Name))
		oeline = append(oeline, "// Please write the conditions under which a state transitions\n")
		oeline = append(oeline, "return true\n")
		oeline = append(oeline, "}\n")
		oeline = append(oeline, "\n")
	}

	return oeline
}

// ------------------------------ hogehoge_test.go -----------------------------------
// テストファイルを生成
func writeTest(otline []string, name string, m map[string]string, key string, count int) []string {
	otline = append(otline, fmt.Sprintf("package %s\n", name))

	otline = append(otline, `

// This is a test file for testing state transitions

import (
	"log"
	"testing"
	"time"
)
`)

	if count == 0 {
		otline = append(otline, `
type DebugStruct struct{}

var logTest = DebugStruct{}

func (l DebugStruct) Println(debstr string) {
	log.Println(debstr)
}
`)
	}

	otline = append(otline, "func TestDevice(t *testing.T) {")
	otline = append(otline, `
	env := sm2go.NewTestEnv() // TestEnv構造体

	// goroutine(base.go Task())
	env.Add(sm2go.Continue, func() {
		for {
			time.Sleep(10 * time.Millisecond)
`)

	otline = append(otline, fmt.Sprintf("%sStep()\n", strings.Title(m[key])))

	otline = append(otline, `
		}
	},
	)

	// goroutine(user operation)
	env.Add(sm2go.Done, func() {
	},
	)

	env.Set(1)
	env.Go()
}
`)

	return otline
}

// ------------------------------　sm2go.go　-----------------------------------
// 　ライブラリを生成
func writeSm(osline []string) []string {
	osline = append(osline, `
package sm2go

import (
	"sync"
	"time"
)

type Tasktype int

const (
	Done Tasktype = iota
	Continue
)

type TestEnv struct {
	task      []func()
	wg        *sync.WaitGroup
	timescale time.Duration
}

func NewTestEnv() *TestEnv {
	return &TestEnv{
		task:      []func(){},
		wg:        &sync.WaitGroup{},
		timescale: 1,
	}
}

func (t *TestEnv) Add(tasktype Tasktype, x func()) {
	switch tasktype {
	case Done:
		t.wg.Add(1)
		t.task = append(t.task, func() {
			defer t.wg.Done()
			x()
		})
	case Continue:
		t.task = append(t.task, x)
	}
}

func (t *TestEnv) Set(i time.Duration) {
	t.timescale = i
}

func (t *TestEnv) Go() {
	for _, x := range t.task {
		go x()
	}
	t.wg.Wait()
}

func (t *TestEnv) Sleep(h time.Duration) {
	time.Sleep(h * t.timescale)
}

func (t *TestEnv) Tick(i time.Duration) <-chan time.Time {
	return time.Tick(i * t.timescale)
}

func (t *TestEnv) After(i time.Duration) <-chan time.Time {
	return time.After(i * t.timescale)
}
`)

	return osline
}

// ------------------------------　main.go　-----------------------------------
func writeMain(omline []string, name string, m map[string]string, key string) []string {
	omline = append(omline, `
// main file

package main

import (
	"time"
)

type DebugStruct struct{}

var logTest = DebugStruct{}

func (l DebugStruct) Println(debstr string) {
	println(debstr)
}

func main() {
	for {
`)

	omline = append(omline, fmt.Sprintf("%s%sStep()\n", name, strings.Title(m[key])))
	omline = append(omline, `
		time.Sleep(time.Millisecond * 10)
	}
}
`)

	return omline
}

// main.goにて実行する関数
func WriteAll(data []byte, name string, key string, v *StateMachine, m map[string]string, count int) ([]string, []string, []string, []string, []string) {
	var oline []string
	var oeline []string
	var otline []string
	var osline []string
	var omline []string

	// ------------------------------　model_base.go　-----------------------------------
	oline = writePackage(oline, name, count)
	oline = writeEnum(oline, v.States, m, key, count)
	oline = writeStep(oline, v.Transitions, m, key)
	oline = writeInit(oline, v.Initial, m, key)
	// ------------------------------　model_impl.go　-----------------------------------
	oeline = writePackageEdit(oeline, name, count)
	oeline = writeFunc(oeline, v.States, v.Events)
	// ------------------------------　model_test.go　-----------------------------------
	otline = writeTest(otline, name, m, key, count)
	// ------------------------------　sm2go.go　-----------------------------------
	osline = writeSm(osline)
	// ------------------------------　main.go　-----------------------------------
	omline = writeMain(omline, name, m, key)

	return oline, oeline, otline, omline, osline
}
